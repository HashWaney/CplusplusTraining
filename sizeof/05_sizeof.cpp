//
// Created by hash on 2020/6/20.
//
#include "iostream"

using namespace std;

//类大小计算
//1。空类大小为1字节
class A {

};
//2。一个类中，虚函数本身，成员函数（静态与非静态）和静态数据成员都是不占用类对象的存储空间

class B {


    //

public:
    char b; //  1  //4 // 第一个成员
    short s; // 2 // 4  // 第二个成员
    int i; //4
    long k; // 8
    double dd; //8
//    virtual void fun() { // 虚函数 64位操作系统，占用8个字节 24 - 40 =16
//
//    };
    static int c; // 静态数据成员被编译器放在一个global data members中，作为类的一个数据成员，不影响类的大小
    static int d;
    static int e;


};
//TODO 字节对齐是如何计算的？？？？ 思考🤔
//一、什么是字节对齐：
//   现代计算机中内存空间都是按照byte划分的，从理论上讲似乎任何类型的变量的访问可以从任何地址开始
//   但是实际情况是访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上
//   排列，而不是顺序的一个接一个的排放。
//二、字节对齐的原因和作用
//   各个硬件平台对存储空间的处理有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取。
//   比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐，
//三、常用类型的对齐方式
//   char       偏移量必须为sizeof(char)      1的倍数
//   int        偏移量必须为sizeof(int)       4的倍数
//   float      偏移量必须为sizeof(float)     4的倍数
//   double     偏移量必须为sizeof(double)    8的倍数
//   short      偏移量必须为sizeof(short)     2的倍数
//   long       偏移量必须为sizeof(long)      8的倍数
//四、如何计算
// 按照声明的成员顺序来依次计算
struct D {
    int i; // 4
    short s; // 看前面的int的地址，是4 则为2的倍数，因此可以紧接着int 往后挪动2个字节的地址空间 4+2 =6
    char c; // 看short的地址，为偏移量为6 为 1的倍数，则 char的地址空间为4+2+1 = 7
    float f; // 看char的地址，为偏移量7 不为4的倍数据，则需要偏移1个字节的地址空间为4+2+1+1 = 8 为4的倍数然后float的所占的内存空间为4+2+1+1+4=12
    long l; // 看float的地址，此时已经为12 不满足8的倍数，同上需要偏移4个字节的地址空间为4+2+1+1+4 + 4=16 为8的倍数， 然后long的内存空间为4+2+1+1+4+4+ 8 =24
    double d; // 看long的地址，此时为24 满足8的倍数，不需要偏移，直接紧接在后面添加8个字节 即4+2+1+1+4+4+8 + 8 =24+8 =30
    void *ptr; // 看double的地址，此时为30 不满足4的倍数，需要偏移2个字节 即32 为4的倍数，然后在向后偏移4个字节， 4+2+1+1+4+4+8+8+2  + 4 =32 +4 =36
};
// 又因为结构体的所占空间是结构体中元素最大所占空间的倍数，即double 8个字节的整数倍，即此时计算的所占空间为36不满足8的倍数，所以还有偏移4个字节 即36+4=40


struct DD {

    int i;

    char c;

    short s;

};

//3。对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针的大小（其实就是一个虚函数指针） 虚指针为8个字节。
class C {
    virtual void fun();

    virtual void fun2();

    virtual void fun3();

    virtual void fun4();
};



//4。普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算
//5。虚函数继承 不管是单继承。还是多继承。都是继承了基类的vptr(虚指针）（32操作系统4个字节，64位操作系统8个字节）
/**
 * 1、普通单继承、继承就是基类+派生类自身的大小（注意字节对齐）
 * - 类的成员按照其声明顺序加入内存。（重要）
 *
 * 2、虚继承、派生类继承基类的虚指针（vptr)
 */
class Base{
public:
    char c; // 1
    int  i; // 4
//    long l;//8
    short s; //2

     // 1+3 int 4 + s 2 = 1+3+4 +2 =10
     //由于字节对齐原则是该成员变量所占最大空间的整数倍 4的整数倍 即10 不满足4的整数倍，因此需要进行偏移2个字节，最小整数倍


};
class BaseHandler{
    Base b; // 12  Base所占空间由以上计算得出 为12
    char a; //1
    // 12+1 =13  实际上 最大的占用空间的为int 的整数倍 13 不是4的整数倍， 因此 最小整除数为16
};


class BaseSample :public Base{
public:

    // 为什么是10 因为BaseSample是继承自Base 因此继承Base中的成员变量，base中的成员变量计算的只为10
//    long a; // 10 + 6 为8的倍数 + 8  16+8 =24 为Base中 4的倍数（为什么这样说，因为Base中int占用字节最多啊，其他可以依次分析）

//    int i; // 10 + 2 为4的倍数 +4 =12+4=16
    char c; // 10 为1的倍数 10+1 =11 但是11 不是 Base中int的倍数 所以还要偏移5个字节 10+1+5 =16

};

//6。虚继承 继承基类的vptr



int main() {
    // 1.
    cout << " 空类的大小 " << sizeof(A) << endl;

    // 2.
    cout << "静态成员类的大小 " << sizeof(B) << endl;

    //3.
    cout << "多个虚函数类的大小 " << sizeof(C) << endl;

    //4.
    cout << "struct的大小 " << sizeof(D) << endl;
    //5.
    cout<<" base handler的大小 "<<sizeof(Base)<<endl; // 12
    cout<<" base Sample 的大小 "<<sizeof(BaseSample)<<endl; //16


}


